\ -----------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by forth-compiler.exe and an image of the VM's initial state is created.
\ It then writes that image to a file specified by -i:<filename>. The default is forth.bin.
\ The image file is read by the VM when it boots.
\
\ The compiler does these things ...
\ - it generates the following words: C, , [ ] (LAST) (HERE) STATE BASE CELL INPUT-FP
\
\ NB: don't inline anything with a 12 in it ... that is RET
\ -----------------------------------------------------------------------------------------------

: LITERAL	   1 C,   ;
: @			[  2 C, ] ; .INLINE
: !			[  3 C, ] ; .INLINE
: SWAP		[  4 C, ] ; .INLINE
: DROP		[  5 C, ] ; .INLINE
: DUP		[  6 C, ] ; .INLINE
: SLITERAL	   7 C,   ;
: JMP		   8 C,   ;
: JMPZ		   9 C,   ;
: JMPNZ		  10 C,   ;
: CALL		  11 C,   ;
: RET		  12 C,   ;
: OR		[ 13 C, ] ; .INLINE
: CLITERAL	  14 C,   ; .INLINE
: C@		[ 15 C, ] ; .INLINE
: C!		[ 16 C, ] ; .INLINE
: +			[ 17 C, ] ; .INLINE
: -			[ 18 C, ] ; .INLINE
: *			[ 19 C, ] ; .INLINE
: /			[ 20 C, ] ; .INLINE
: <			[ 21 C, ] ; .INLINE
: =			[ 22 C, ] ; .INLINE
: >			[ 23 C, ] ; .INLINE
: DICTP		  24 C,   ; .INLINE
: EMIT		[ 25 C, ] ; .INLINE
: OVER		[ 26 C, ] ; .INLINE
: COMPARE	[ 27 C, ] ; .INLINE
: FOPEN		[ 28 C, ] ; .INLINE
: FREAD		[ 29 C, ] ; .INLINE
: FREADLINE	[ 30 C, ] ; .INLINE
: FWRITE	[ 31 C, ] ; .INLINE
: FCLOSE	[ 32 C, ] ; .INLINE
: >R		[ 33 C, ] ; .INLINE
: R>		[ 34 C, ] ; .INLINE
: LOGLEVEL	[ 35 C, ]  ; .INLINE
: AND		[ 36 C, ] ; .INLINE
: PICK		[ 37 C, ] ; .INLINE
: DEPTH		[ 38 C, ] ; .INLINE
: GETCH		[ 39 C, ] ; .INLINE
: COMPAREI	[ 40 C, ] ; .INLINE
: USINIT	[ 41 C, ] ; .INLINE
: USPUSH	[ 42 C, ] ; .INLINE
: USPOP		[ 43 C, ] ; .INLINE
: BREAK		[ 253 C, ] ; .INLINE
: RESET		[ 254 C, ] ; .INLINE
: BYE		[ 255 C, ] ; .INLINE

\ ------------------------------------------------------------------------------------
: INLINE    (LAST) @ 2 CELL * + DUP C@ 2 OR SWAP C! ;
: IMMEDIATE (LAST) @ 2 CELL * + DUP C@ 1 OR SWAP C! ;
: CELLS CELL * ; INLINE

: LAST (LAST) @ ; INLINE
: HERE (HERE) @ ; INLINE

\ ------------------------------------------------------------------------------------
: R@      R> DUP >R       ; INLINE
: RDROP   R> DROP         ; INLINE
: 2DUP    OVER OVER       ; INLINE
: 2DROP   DROP DROP       ; INLINE
: TUCK    SWAP OVER       ; INLINE
: NIP     SWAP DROP       ; INLINE
: ROT     >R SWAP R> SWAP ; INLINE
: -ROT    SWAP >R SWAP R> ; INLINE

\ ------------------------------------------------------------------------------------
: ?COMPILING STATE @ ;
: IF   ?COMPILING .IF JMPZ HERE 0 ,                  .THEN ; IMMEDIATE
: ELSE ?COMPILING .IF JMP  HERE SWAP 0 , HERE SWAP ! .THEN ; IMMEDIATE
: THEN ?COMPILING .IF HERE SWAP !                    .THEN ; IMMEDIATE

: BEGIN ?COMPILING IF HERE    THEN ;    IMMEDIATE 
: AGAIN ?COMPILING IF JMP   , THEN ;    IMMEDIATE
: WHILE ?COMPILING IF JMPNZ , THEN ;    IMMEDIATE
: UNTIL ?COMPILING IF JMPZ  , THEN ;    IMMEDIATE
: LEAVE ?COMPILING IF RET     THEN ;    IMMEDIATE

\ ------------------------------------------------------------------------------------
: COUNT DUP 1 + SWAP C@ ;		\ ( addr1 --  addr2 num )

: TYPE                          \ ( addr count -- ) 
	OVER + 1 - SWAP
	BEGIN
		2DUP < IF 
            DROP DROP LEAVE 
        THEN
		DUP C@ EMIT 1 +
	AGAIN ;

: CR 13 EMIT 10 EMIT ;

\ ------------------------------------------------------------------------------------
: INPUT-FP [ LITERAL HERE CELL + 1 + , ] ; 0 , RET
: PAD LAST 256 - ;

\ ------------------------------------------------------------------------------------
: string-nullterm               \ ( counted-str -- )
    0 SWAP DUP C@ + 1 + C! ;

\ ------------------------------------------------------------------------------------
: string-catc          			\ ( ch addr -- )
    TUCK DUP C@ + 1 + C!
    DUP C@ 1 + SWAP C! ;

\ ------------------------------------------------------------------------------------
: string-popc          			\ ( addr -- ch )
    DUP C@ IF
        DUP C@ 1 - OVER C!
        DUP C@ + 1 + C@
    ELSE
        DROP 0
    THEN ;

\ ------------------------------------------------------------------------------------
: BETWEEN						\ ( num min max -- bool )
	2 PICK < IF
        DROP DROP 0 LEAVE 
    THEN
	< 0 = ;

\ ------------------------------------------------------------------------------------
: file-getLine		            \ ( fp -- counted-str )
	PAD SWAP 200 SWAP
	FREADLINE                   \ ( addr sz fp -- num-read )
    \ NOTE: 0 bytes read means <EOF>
	PAD C! 
	\ PAD COUNT TYPE CR \ DEBUG
    PAD ;

\ ------------------------------------------------------------------------------------
: stdin-getline		            \ ( -- counted-str )
	PAD 0 OVER ! >R
    BEGIN
		GETCH 

        \ <CTRL>-C?
		DUP 3 = IF 
            S" <CTRL>-C" COUNT TYPE
            BYE
        THEN

        \ <CARRIAGE-RETURN>?
		DUP 13 = IF 
			DROP R>
            32 EMIT
            LEAVE
		THEN

        \ <BACKSPACE>?
        DUP 8 = IF
            R@ string-popc DROP
            DUP EMIT 32 EMIT EMIT
        ELSE
            DUP 32 127 BETWEEN IF
                DUP EMIT
                R@ string-catc
            ELSE
                DROP
            THEN
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: get-line                      \ ( -- counted-str )
    INPUT-FP @ DUP IF
        file-getLine
    ELSE
        DROP stdin-getline
    THEN ;

\ ------------------------------------------------------------------------------------
: skip-ws                       \ ( addr1 -- addr2 )
    \ addr1 => input: start of input string
    \ addr2 => output: next non-whitespace char or <EOL>
    BEGIN
        DUP C@ 
        1 32 BETWEEN IF 
            1 +
        ELSE
            LEAVE
        THEN
    AGAIN ;     

\ ------------------------------------------------------------------------------------
: get-word                      \ ( addr1 -- counted-str addr2 )
	\ NB: this word assumes that any
	\ leading whitespace has already been skipped.
    \ addr1 => input: start of input string
    \ addr2 => output: next char in string after the word
    HERE 64 + DUP >R 0 SWAP !
    BEGIN
        DUP C@ DUP
        33 < IF 
            DROP R> SWAP DUP string-nullterm
            LEAVE
        ELSE
            R@ string-catc
            1 +
        THEN
    AGAIN ;     

\ ------------------------------------------------------------------------------------
: DICT>NEXT                  ;  INLINE
: DICT>XT     CELL +         ;  INLINE
: DICT>FLAGS  2 CELLS +      ;  INLINE
: DICT>NAME   DICT>FLAGS 1 + ;  INLINE
: FLAG_IMMEDIATE 1 ; INLINE
: FLAG_INLINE    2 ; INLINE

\ ------------------------------------------------------------------------------------
: find-word						\ ( counted-str -- (addr 1) | 0 )
    \ S" Looking for " COUNT TYPE DUP COUNT TYPE
    DUP string-nullterm
	LAST >R
	BEGIN
		R@ DUP IF
            \ DUP DICT>NAME COUNT TYPE
			DICT>NAME OVER COMPAREI
			IF
                \ S" .word." COUNT TYPE
				DROP R> 1
				LEAVE
			THEN
		ELSE
            \ S" .not-word." COUNT TYPE
			DROP DROP R> DROP 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

\ ------------------------------------------------------------------------------------
: is-num-char?						\ ( ch -- (val 1) | 0 )
    DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	BASE C@ 16 = IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	DROP 0 ;

: is-number?                        \ ( counted-str -- (num 1) | 0 )
    \ null-terminate it and skip the count-byte
    DUP string-nullterm 1 +

	\ find out if it is negative
	DUP C@ 45 = IF
        1 >R 1 +
    ELSE
        0 >R
    THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
        DUP 0 = IF \ end of word?
			DROP DROP R> 
            \ S" .number." COUNT TYPE
			R> IF
                \ S" negative." COUNT TYPE
                0 SWAP - 
            THEN
			1 LEAVE
		THEN

		is-num-char? IF
			R> BASE C@ * + >R
			1 +
		ELSE
            \ S" .not-number." COUNT TYPE
			DROP R> DROP R> DROP 
            0 LEAVE
		THEN
	AGAIN ;

\ ------------------------------------------------------------------------------------
: execute-word                  \ ( counted-str -- )
    \ check to see if it's a number
    DUP is-number? IF
        SWAP DROP
        ?COMPILING IF
            \ compile the number as a value that is pushed on the stack
            DUP 255 > IF
                LITERAL ,
            ELSE
                CLITERAL C,
            THEN
        \ no ELSE ... just leave the number on the stack
        THEN
        LEAVE
    THEN

    DUP find-word IF
        SWAP DROP
        \ Execute the word or compile it here
        \ Get the XT
        DICT>XT @
        ?COMPILING IF
            \ IF it's IMMEDIATE, call it
            \ ELSE IF it's INLINE, copy the bytes until the first RET (12)
            \ ELSE, compile a CALL to it
            CALL , DROP
        ELSE
            \ Execute it
            >R
        THEN
        LEAVE
    THEN

    \ If we get here, it is neither a word nor a number ... ERROR!
    COUNT TYPE 63 DUP EMIT EMIT ;

\ ------------------------------------------------------------------------------------
: >IN [ LITERAL HERE CELL + 1 + , ] ; 0 , RET

\ ------------------------------------------------------------------------------------
: execute-line                  \ ( -- )
    BEGIN 
        >IN @ skip-ws >IN !

        \ >IN now points to the start of the first word, or NULL if <EOL>
        >IN @ C@ 0 = IF
            LEAVE
        THEN

        >IN @ get-word >IN !
        \ <TOS> is now the word to execute
        execute-word
    AGAIN ;

\ ------------------------------------------------------------------------------------
: ok STATE @ 0 = IF 
        INPUT-FP @ 0 = IF
            S"  Ok" COUNT TYPE CR
        THEN
    THEN ;

\ ------------------------------------------------------------------------------------
: mainloop 0 STATE ! 
    BEGIN 
        ok get-line
        DUP C@ IF
            \ NULL terminate the line 
            \ and skip the count byte
            DUP string-nullterm 1 + >IN !
            execute-line 
        ELSE
            DROP INPUT-FP @ IF
                INPUT-FP @ FCLOSE
                0 INPUT-FP !
            THEN
        THEN
        \ BYE
    AGAIN ;

\ ------------------------------------------------------------------------------------
: /MOD 2DUP / DUP >R * - R> SWAP ;     \ ( num1 num2 -- num3 mod )

\ ------------------------------------------------------------------------------------
: (.)			\ ( num -- )
	DUP 0 = 
	IF
		DROP 48 EMIT LEAVE
	THEN
	
	DUP 0 < IF 0 - 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP
		IF
			BASE C@ /MOD
			48 OVER 9 > IF 7 + THEN
			+ SWAP
		ELSE
			\ spit out the string
			DROP
			R> IF 45 EMIT THEN
			BEGIN DUP IF EMIT ELSE DROP LEAVE THEN AGAIN
		THEN
	AGAIN
;

: . 32 EMIT (.) ;

\ ------------------------------------------------------------------------------------
: main S" Hello." COUNT TYPE 
    0 INPUT-FP ! 
    LAST DICT>XT @ 
    1 !
    mainloop ;

\ ------------------------------------------------------------------------------------
: reset-data-stack 
    BEGIN
        DEPTH IF
            DROP 
        ELSE
            LEAVE
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: RDEPTH
    \ TODO
    0 ;

\ ------------------------------------------------------------------------------------
: reset-return-stack
    \ NOTE: save the last return address
    R>
    BEGIN
        RDEPTH IF
            R> DROP 
        ELSE
            >R
            LEAVE
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: exception 
    S"  (exception) " COUNT TYPE 
    0 STATE !
    reset-data-stack
    reset-return-stack
    mainloop ;
