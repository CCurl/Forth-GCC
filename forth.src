\ -----------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by forth-compiler.exe and an image of the VM's initial state is created.
\ It then writes that image to a file specified by -i:<filename>. The default is forth.bin.
\ The image file is read by the VM when it boots.
\
\ The compiler does these things ...
\ - it generates the following words: C, , [ ] (LAST) (HERE) STATE BASE CELL
\
\ NB: don't inline anything with a 12 in it ... that is RET
\ -----------------------------------------------------------------------------------------------

: LITERAL	   1 C,   ;
: @			[  2 C, ] ; .INLINE
: !			[  3 C, ] ; .INLINE
: SWAP		[  4 C, ] ; .INLINE
: DROP		[  5 C, ] ; .INLINE
: DUP		[  6 C, ] ; .INLINE
: SLITERAL	   7 C,   ;
: JMP		   8 C,   ;
: JMPZ		   9 C,   ;
: JMPNZ		  10 C,   ;
: CALL		  11 C,   ;
: RET		  12 C,   ;
: OR		[ 13 C, ] ; .INLINE
: CLITERAL	  14 C,   ; .INLINE
: C@		[ 15 C, ] ; .INLINE
: C!		[ 16 C, ] ; .INLINE
: +			[ 17 C, ] ; .INLINE
: -			[ 18 C, ] ; .INLINE
: *			[ 19 C, ] ; .INLINE
: /			[ 20 C, ] ; .INLINE
: <			[ 21 C, ] ; .INLINE
: =			[ 22 C, ] ; .INLINE
: >			[ 23 C, ] ; .INLINE
: DICTP		  24 C,   ; .INLINE
: EMIT		[ 25 C, ] ; .INLINE
: OVER		[ 26 C, ] ; .INLINE
: COMPARE	[ 27 C, ] ; .INLINE
: FOPEN		[ 28 C, ] ; .INLINE
: FREAD		[ 29 C, ] ; .INLINE
: FREADLINE	[ 30 C, ] ; .INLINE
: FWRITE	[ 31 C, ] ; .INLINE
: FCLOSE	[ 32 C, ] ; .INLINE
: >R		[ 33 C, ] ; .INLINE
: R>		[ 34 C, ] ; .INLINE
: LOGLEVEL	[ 35 C, ] ; .INLINE
: AND		[ 36 C, ] ; .INLINE
: PICK		[ 37 C, ] ; .INLINE
: DEPTH		[ 38 C, ] ; .INLINE
: GETCH		[ 39 C, ] ; .INLINE
: COMPAREI	[ 40 C, ] ; .INLINE
: USINIT	[ 41 C, ] ; .INLINE
: USPUSH	[ 42 C, ] ; .INLINE
: USPOP		[ 43 C, ] ; .INLINE
: BREAK		[ 253 C, ] ; .INLINE
: RESET		[ 254 C, ] ; .INLINE
: BYE		[ 255 C, ] ; .INLINE

\ ------------------------------------------------------------------------------------
: R@        R> DUP >R  ; .INLINE

\ ------------------------------------------------------------------------------------
\ : INLINE 0 DROP ;              \    (LAST) @ 2 CELL * + DUP C@ 2 OR SWAP C! ;
: INLINE    (LAST) @ 2 CELL * + DUP C@ 2 OR SWAP C! ;
: IMMEDIATE (LAST) @ 2 CELL * + DUP C@ 1 OR SWAP C! ;
: CELLS CELL * ; INLINE

: LAST (LAST) @ ; INLINE
: HERE (HERE) @ ; INLINE

\ ------------------------------------------------------------------------------------
: ?COMPILING STATE @ ;
: IF   ?COMPILING .IF JMPZ HERE 0 ,                  .THEN ; IMMEDIATE
: ELSE ?COMPILING .IF JMP  HERE SWAP 0 , HERE SWAP ! .THEN ; IMMEDIATE
: THEN ?COMPILING .IF HERE SWAP !                    .THEN ; IMMEDIATE

: BEGIN ?COMPILING IF HERE    THEN ;    IMMEDIATE 
: AGAIN ?COMPILING IF JMP   , THEN ;    IMMEDIATE
: WHILE ?COMPILING IF JMPNZ , THEN ;    IMMEDIATE
: UNTIL ?COMPILING IF JMPZ  , THEN ;    IMMEDIATE
: LEAVE ?COMPILING IF RET     THEN ;    IMMEDIATE

\ ------------------------------------------------------------------------------------
: COUNT DUP 1 + SWAP C@ ;		\ ( addr1 --  addr2 num )

: TYPE                          \ ( addr count -- ) 
	OVER + 1 - SWAP
	BEGIN
		OVER OVER < IF 
            DROP DROP LEAVE 
        THEN
		DUP C@ EMIT 1 +
	AGAIN ;

: CR 13 EMIT 10 EMIT ;

\ ------------------------------------------------------------------------------------
: INPUT-FP [ LITERAL HERE CELL + 1 + , ] ; 0 , RET
: PAD LAST 256 - ;

\ ------------------------------------------------------------------------------------
: string-nullterm               \ ( counted-str -- )
    0 SWAP DUP C@ + 1 + C! ;

\ ------------------------------------------------------------------------------------
: string-catc          			\ ( ch addr -- )
    SWAP OVER DUP C@ + 1 + C!
    DUP C@ 1 + SWAP C! ;

\ ------------------------------------------------------------------------------------
: string-copy                   \ ( from-cstr to-ctr -- )
    >R DUP C@ OVER + 1 + SWAP
    BEGIN
        OVER OVER = IF
            DROP DROP
            R> DROP
            LEAVE
        ELSE
            DUP C@ 
            R@ C! R> 1 + >R
            1 +
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: string-popc          			\ ( addr -- ch )
    DUP C@ IF
        DUP C@ 1 - OVER C!
        DUP C@ + 1 + C@
    ELSE
        DROP 0
    THEN ;

\ ------------------------------------------------------------------------------------
: BETWEEN						\ ( num min max -- bool )
	2 PICK < IF
        DROP DROP 0 LEAVE 
    THEN
	< 0 = ;

\ ------------------------------------------------------------------------------------
: stdin-getline		            \ ( -- counted-str )
	PAD 0 OVER ! >R
    BEGIN
		GETCH 

        \ <CTRL>-C?
		DUP 3 = IF 
            S" <CTRL>-C" COUNT TYPE
            BYE
        THEN

        \ <CARRIAGE-RETURN>?
		DUP 13 = IF 
			DROP R>
            32 EMIT
            LEAVE
		THEN

        \ <TAB>?
        DUP 9 = IF
            DROP 32
        THEN

        \ <BACKSPACE>?
        DUP 8 = IF
            R@ string-popc DROP
            DUP EMIT 32 EMIT EMIT
        ELSE
            DUP 32 127 BETWEEN IF
                DUP EMIT
                R@ string-catc
            ELSE
                DROP
            THEN
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: file-getLine		                        \ ( -- counted-str )
	PAD 200 INPUT-FP @ FREADLINE            \ FREADLINE: ( addr sz fp -- num-read )
    \ NOTE: 0 bytes read means <EOF>
    0 = IF
        INPUT-FP @ FCLOSE
        0 INPUT-FP !
    ELSE
        46 EMIT PAD COUNT TYPE \ DEBUG

    THEN
    PAD ;

\ ------------------------------------------------------------------------------------
: get-line                      \ ( -- counted-str )
    INPUT-FP @ IF
        file-getLine
    ELSE
        stdin-getline
    THEN ;

\ ------------------------------------------------------------------------------------
: skip-ws                       \ ( addr1 -- addr2 )
    \ addr1 => input: start of input string
    \ addr2 => output: next non-whitespace char or <EOL>
    BEGIN
        DUP C@ 
        1 32 BETWEEN IF 
            1 +
        ELSE
            LEAVE
        THEN
    AGAIN ;     

\ ------------------------------------------------------------------------------------
: get-word                      \ ( addr1 -- counted-str addr2 )
	\ NB: this word assumes that any
	\ leading whitespace has already been skipped.
    \ addr1 => input: start of input string
    \ addr2 => output: next char in string after the word
    HERE 256 + DUP >R 0 SWAP !
    BEGIN
        DUP C@ DUP
        33 < IF 
            DROP R@ string-nullterm
            R> SWAP LEAVE
        ELSE
            R@ string-catc
            1 +
        THEN
    AGAIN ;     

\ ------------------------------------------------------------------------------------
: DICT>NEXT                  ;  INLINE
: DICT>XT       CELL  +      ;  INLINE
: DICT>FLAGS  2 CELLS +      ;  INLINE
: DICT>NAME   DICT>FLAGS 1 + ;  INLINE
: FLAG_IMMEDIATE 1           ; INLINE
: FLAG_INLINE    2           ; INLINE

\ ------------------------------------------------------------------------------------
: find-word						\ ( counted-str -- (addr 1) | 0 )
    \ S" Looking for " COUNT TYPE DUP COUNT TYPE
    DUP string-nullterm
	LAST >R
	BEGIN
		R@ DUP IF
            \ DUP DICT>NAME COUNT TYPE
			DICT>NAME OVER COMPAREI
			IF
                \ S" .found-it." COUNT TYPE
				DROP R> 1
				LEAVE
			THEN
		ELSE
            \ S" .not-word." COUNT TYPE
			DROP DROP R> DROP 0 LEAVE
		THEN
		R> @ >R
	AGAIN ;

\ ------------------------------------------------------------------------------------
: define-word		                \ ( name-cstr -- )
	LAST OVER C@ 2 CELLS 3 + + -    \ New-LAST
	DUP >R >R					    \ Save it
	LAST R@  !  R> CELL + >R	    \ NEXT
	HERE R@  !  R> CELL + >R	    \ XT
	0    R@ C!  R> 1    + >R        \ FLAGS
	R> string-copy				    \ LEN + NAME
	R> (LAST) ! ;

\ ------------------------------------------------------------------------------------
: is-num-char?						\ ( ch -- (val 1) | 0 )
    DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	BASE C@ 16 = IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	DROP 0 ;

\ ------------------------------------------------------------------------------------
: is-number?                        \ ( counted-str -- (num 1) | 0 )
    \ null-terminate it and skip the count-byte
    DUP string-nullterm 1 +

	\ find out if it is negative
	DUP C@ 45 = IF
        1 >R 1 +
    ELSE
        0 >R
    THEN

    \ '-' by itself is not a number
    DUP C@ 0 = IF DROP R> DROP 0 LEAVE THEN

	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
        DUP 0 = IF \ end of word?
			DROP DROP R> 
            \ S" .number." COUNT TYPE
			R> IF
                \ S" negative." COUNT TYPE
                0 SWAP - 
            THEN
			1 LEAVE
		THEN

		is-num-char? IF
			R> BASE C@ * + >R
			1 +
		ELSE
            \ S" .not-number." COUNT TYPE
			DROP R> DROP R> DROP 
            0 LEAVE
		THEN
	AGAIN ;

\ ------------------------------------------------------------------------------------
: >IN [ LITERAL HERE CELL + 1 + , ] ; 0 , RET

\ ------------------------------------------------------------------------------------
: CREATE-NAME		                \ ( -- )
	>IN @ skip-ws >IN ! 

    \ <EOL>?
	>IN @ C@ 0 = IF 
        LEAVE
    THEN

    >IN @ get-word >IN ! 
    define-word
    DICTP
    LAST , ;

: : CREATE-NAME 1 STATE ! ;
: ; RET         0 STATE ! ; IMMEDIATE

\ ------------------------------------------------------------------------------------
: execute-word                  \ ( counted-str -- )
    \ check to see if it's a number
    DUP is-number? IF
        SWAP DROP
        ?COMPILING IF
            \ compile the number as a value that is pushed on the stack
            DUP 255 > IF
                LITERAL ,
            ELSE
                CLITERAL C,
            THEN
        \ no ELSE ... just leave the number on the stack
        THEN
        LEAVE
    THEN

    \ DUP COUNT TYPE
    DUP find-word IF
        SWAP DROP
        \ Execute the word or compile it here
        ?COMPILING IF
            \ IF it's IMMEDIATE, call it
            DUP DICT>FLAGS C@ FLAG_IMMEDIATE = IF
                \ S" (imm)" COUNT TYPE
                DICT>XT @
                >R LEAVE
            ELSE
                DUP DICT>FLAGS C@ FLAG_INLINE = IF
                    \ INLINE ... copy the bytes until the first RET (12)
                    CALL DICT>XT @ ,
                ELSE
                    \ Compile a CALL to it
                    CALL DICT>XT @ ,
                THEN
            THEN
        ELSE
            \ Execute it
            DICT>XT @
            >R LEAVE
        THEN
        LEAVE
    THEN

    \ If we get here, it is neither a word nor a number ... ERROR!
    COUNT TYPE 63 DUP EMIT EMIT 
    INPUT-FP @ IF
        INPUT-FP @ FCLOSE
        0 INPUT-FP !
    THEN
    0 STATE ! ;

\ ------------------------------------------------------------------------------------
: execute-line                  \ ( -- )
    BEGIN 
        >IN @ skip-ws >IN !

        \ >IN now points to the start of the first word, or NULL if <EOL>
        >IN @ C@ 0 = IF
            LEAVE
        THEN

        >IN @ get-word >IN !
        \ <TOS> is now the word to execute
        execute-word
    AGAIN ;

\ ------------------------------------------------------------------------------------
: ok STATE @ 0 = IF 
        INPUT-FP @ 0 = IF
            S"  Ok" COUNT TYPE CR
        ELSE S" .ok." COUNT TYPE
        THEN
    ELSE S" (ok)" COUNT TYPE
    THEN ;

\ ------------------------------------------------------------------------------------
: mainloop 
    0 STATE ! 
    BEGIN 
        ok get-line
        DUP C@ IF
            \ NULL terminate the line 
            \ and skip the count byte
            DUP string-nullterm 1 + >IN !
            execute-line 
        ELSE
            DROP INPUT-FP @ IF
                INPUT-FP @ FCLOSE
                0 INPUT-FP !
            THEN
        THEN
        \ BYE
    AGAIN ;

\ ------------------------------------------------------------------------------------
: main S" Hello." COUNT TYPE 
    0 INPUT-FP ! 
    LAST DICT>XT @ 
    1 !
    mainloop ;

\ ------------------------------------------------------------------------------------
: reset-data-stack 
    BEGIN
        DEPTH IF
            DROP 
        ELSE
            LEAVE
        THEN
    AGAIN ;

\ ------------------------------------------------------------------------------------
: RDEPTH
    \ TODO
    0 ;

\ ------------------------------------------------------------------------------------
: reset-return-stack
    \ NOTE: save the last return address
    R>
    BEGIN
        RDEPTH IF
            R> DROP 
        ELSE
            >R
            LEAVE
        THEN
    AGAIN ;

: \ 0 >IN @ ! ; IMMEDIATE

\ ------------------------------------------------------------------------------------
: /MOD OVER OVER / DUP >R * - R> SWAP ;     \ ( num1 num2 -- num3 mod )

\ ------------------------------------------------------------------------------------
: (.)
	DUP 0 = 
	IF
		DROP 48 EMIT LEAVE
	THEN
	
	DUP 0 < IF 0 - 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP
		IF
			BASE C@ /MOD
			48 OVER 9 > IF 7 + THEN
			+ SWAP
		ELSE
			DROP
			R> IF 45 EMIT THEN
			BEGIN DUP IF EMIT ELSE DROP LEAVE THEN AGAIN
		THEN
	AGAIN ;

: BL 32 EMIT ; INLINE

: . BL (.) ;

: LOAD                          \ ( name-cstr -- )
    DUP string-nullterm
    0 0 FOPEN IF
        INPUT-FP !
    ELSE
        DROP 
        S"  unable to open the file." COUNT TYPE
    THEN ;

: LL S" words.4th" LOAD ;

\ ------------------------------------------------------------------------------------
: exception 
    S"  (exception) " COUNT TYPE 
    0 STATE !
    reset-data-stack
    reset-return-stack
    mainloop ;

: countTo 
    BEGIN
        OVER OVER < IF DROP DROP LEAVE THEN
        DUP DUP DROP DROP
        DUP DUP DROP DROP
        1 +
    AGAIN ;

: doCount 100000000 0 countTo ;

: getWord HERE 256 + 0 OVER ! DUP >R
    BEGIN
        GETCH DUP 33 < IF
            R@ C@ IF
                DROP R> DUP C@ LEAVE
            THEN
            DROP
        ELSE
            DUP 128 < IF
                R@ string-catc
            ELSE 
                DROP
            THEN
        THEN
    AGAIN ;

: test-gw getWord . COUNT TYPE ;
