\ ------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by forth-compiler.exe and an image of the VM's initial state is created.
\ It then writes that image to a file specified by -i:<filename>. The default is forth.bin.
\ It also disassembles that image, creating a listing file named by the -o arg, forth.asm.
\ The image file is read by the VM when it boots.
\
\ NB: don't inline anything with a 12 in it ... that is RET
\ ------------------------------------------------------------------------------------------

.ORG 32

\ The compiler/dis-assembler is hard-coded to put these values here ...
: CELL   7 C@ ; INLINE
: DP       16 ; INLINE   \ Where the current HERE is stored
: (LAST)   20 ; INLINE
: BASE     24 ; INLINE
: INPUT-FP 28 ; INLINE

: HERE DP     @ ; INLINE
: LAST (LAST) @ ; INLINE

: CELLS CELL * ; \ ( num1 -- num2 )

: (MEM_K)   <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA
: STATE     <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA
: >IN       <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA
: isNeg     <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA

: MEM_SZ (MEM_K) @ 1024 * ;
16 (MEM_K) !

\ : STDIN <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA

: !  <asm> STORE  </asm> ; INLINE
: C! <asm> CSTORE </asm> ; INLINE

: @  <asm> FETCH  </asm> ; INLINE
: C@ <asm> CFETCH </asm> ; INLINE

: + <asm> ADD </asm> ; INLINE
: - <asm> SUB </asm> ; INLINE
: * <asm> MUL </asm> ; INLINE
: / <asm> DIV </asm> ; INLINE

: 1+ 1 + ; INLINE
: 1- 1 - ; INLINE

: 2* 2 * ; INLINE 
: 2/ 2 / ; INLINE

: AND <asm> AND </asm> ; INLINE
: OR  <asm> OR  </asm> ; INLINE

: >R <asm> DTOR   </asm> ; INLINE
: R> <asm> RTOD   </asm> ; INLINE
: R@ R> DUP >R ; INLINE

: < <asm> LT </asm> ; INLINE
: = <asm> EQ </asm> ; INLINE
: > <asm> GT </asm> ; INLINE

: DUP  <asm> DUP  </asm> ; INLINE
: SWAP <asm> SWAP </asm> ; INLINE
: DROP <asm> DROP </asm> ; INLINE
: OVER <asm> OVER </asm> ; INLINE
: PICK <asm> PICK </asm> ; INLINE

: DEPTH <asm> DEPTH </asm> ; INLINE
: RESET <asm> RESET </asm> ; INLINE
: BREAK <asm> BREAK </asm> ; INLINE
: BYE   <asm> BYE   </asm> ; INLINE

: EMIT  <asm> EMIT  </asm> ; INLINE
: ZTYPE <asm> ZTYPE </asm> ; INLINE
: GETCH <asm> GETCH </asm> ; INLINE

: FOPEN     <asm> FOPEN     </asm> ; INLINE
: FREAD     <asm> FREAD     </asm> ; INLINE
: FREADLINE <asm> FREADLINE </asm> ; INLINE
: FWRITE    <asm> FWRITE    </asm> ; INLINE
: FCLOSE    <asm> FCLOSE    </asm> ; INLINE

: COMPARE <asm> COMPARE </asm> ; INLINE
: COMPAREI <asm> COMPAREI </asm> ; INLINE

: RDROP R> DROP   ; INLINE
: TUCK  SWAP OVER ; INLINE
: NIP   SWAP DROP ; INLINE
: ROT   >R SWAP R> SWAP ;
: -ROT  SWAP >R SWAP R> ;

: += OVER @        + SWAP ! ;   \ ( addr n -- )
: -= OVER @   SWAP - SWAP ! ;   \ ( addr n -- )

: ++ 1 += ;   \ ( addr -- )
: -- 1 -= ;   \ ( addr -- )

: C++ DUP C@ 1+ SWAP C! ;   \ ( addr -- )
: C-- DUP C@ 1- SWAP C! ;   \ ( addr -- )

: +!  TUCK @  + SWAP !  ;
: C+! TUCK C@ + SWAP C! ;

: ,  HERE !  CELL DP +! ;
: C, HERE C!      DP ++ ;

: 0= 0 =  ; INLINE
: <> = 0= ; INLINE
: <= > 0= ; INLINE
: >= < 0= ; INLINE

: TRUE 1 ; INLINE
: FALSE 0 ; INLINE
: NOT 0 = ; INLINE

: 2DUP  OVER OVER ; INLINE
: 2DROP DROP DROP ; INLINE

: COUNT DUP 1+ SWAP C@ ;		\ ( addr1 --  addr2 num )

: TYPE \ ( addr count -- ) 
    BEGIN
	    DUP 0=
		IF
            2DROP LEAVE
        THEN
        SWAP DUP C@ EMIT 1+ SWAP 1-
    AGAIN ;

: CT COUNT TYPE ;

: ?COMPILING STATE @ ;
: [ 0 STATE ! ; IMMEDIATE
: ] 1 STATE ! ; IMMEDIATE

: COMPILING-ONLY!
	?COMPILING NOT IF
		S"  compiling only!" CT RESET 
	THEN ;

: LEAVE COMPILING-ONLY! <asm> CPUSH RET </asm> C, ; IMMEDIATE

: IF   ?COMPILING IF <asm> CPUSH JMPZ </asm> C, HERE 0 , THEN ; IMMEDIATE
: ELSE ?COMPILING IF <asm> CPUSH JMP  </asm> C, HERE SWAP 0 , HERE SWAP ! THEN ; IMMEDIATE
: THEN ?COMPILING IF HERE SWAP ! THEN ; IMMEDIATE

: BEGIN ?COMPILING IF HERE THEN ; IMMEDIATE
: AGAIN ?COMPILING IF <asm> CPUSH JMP   </asm> C, , THEN ; IMMEDIATE
: WHILE ?COMPILING IF <asm> CPUSH JMPNZ </asm> C, , THEN ; IMMEDIATE
: UNTIL ?COMPILING IF <asm> CPUSH JMPZ  </asm> C, , THEN ; IMMEDIATE

: \ 0 >IN @ C! ; IMMEDIATE

: ( BEGIN 
	>IN @ C@ 
	DUP 0= IF 
		S" missing closing ')'" CT RESET
	THEN
	>IN ++		
	41 = IF		\ 41 = ')'
		LEAVE 
	THEN
	AGAIN ; IMMEDIATE

: CRLF 13 EMIT 10 EMIT ;
: CR CRLF ;
: BL 32 EMIT ; INLINE

: ON 1 SWAP ! ; : OFF 0 SWAP ! ;

: BETWEEN				\ ( num min max -- bool )
	2 PICK 
	< IF 2DROP 0 LEAVE THEN
	< 0=
;

: (tmp) <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA
: tmp-init LAST (tmp) ! ;				\ ( -- )
: tmp-cur (tmp) @ ;
: tmp-alloc (tmp) TUCK @ SWAP - SWAP ! tmp-cur ; \ ( size -- addr )
tmp-init

: PAD tmp-init 200 tmp-alloc ;
: getInput PAD 128 0 FREADLINE DROP PAD ; \ ( -- addr )
: ?DUP DUP IF DUP THEN ;

: HEX     16 BASE ! ;
: DECIMAL 10 BASE ! ;
: OCTAL    8 BASE ! ;
: BINARY   2 BASE ! ;

: skipWS               \ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		IF
			32 > 
			IF LEAVE ELSE 1+ THEN
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

\ NB: this word assumes that leading WS has already been skipped.
: getOneWord \ ( addr1 -- word-addr addr2 )
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			\ If not at the end of the line, stick a 
			\ ZERO here and go to the next char.
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: DICT>NEXT ;
: DICT>XT     CELL + ;
: DICT>FLAGS  2 CELLS + ;
: DICT>NAME   DICT>FLAGS 1+ ;

: NEXT>DICT ;
: XT>DICT     CELL - ;
: FLAGS>DICT  2 CELLS - ;
: NAME>DICT   1- 2 CELLS - ;

: DICT.GetXT DICT>XT @ ;
: DICT.GetFLAGS DICT>FLAGS C@ ;

: DICTP>NAME 1+ @ DICT>NAME ;

: XT.GetDICTP \ ( XT -- dictp )
	DUP C@ <asm> CPUSH DICTP </asm> = 
	IF
		1+ @
	ELSE
		DROP RESET
	THEN
;

: FLAG_IMMEDIATE 1 ;
: FLAG_INLINE    2 ;

: FLAGS.ISIMMEDIATE? FLAG_IMMEDIATE AND ;
: FLAGS.ISINLINE?    FLAG_INLINE    AND ;

: DICT.GetIMMEDIATE DICT.GetFLAGS FLAGS.ISIMMEDIATE? ;
: DICT.GetINLINE    DICT.GetFLAGS FLAGS.ISINLINE? ;

: findInDict \ ( addr -- XT IMM bool )
	LAST >R
	BEGIN
		R@ DUP
		IF
			\ addr is a null-termnated string with no count byte
			DICT>NAME 1+ OVER COMPAREI
			IF
				DROP R@ DICT.GetXT R> DICT.GetFLAGS 1
				LEAVE
			THEN
		ELSE
			2DROP R> 0 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

: isHEX? BASE @ 16 = ;

: isNumChar? \ ( ch -- val bool )
	DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	isHEX? 
	IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	0
;

: NEGATE 0 SWAP - ;
: ABS DUP 0 < IF NEGATE THEN ;

: isNumber? \ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP isNeg C! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0 = \ end of word?
		IF 
			2DROP R> 
			isNeg C@ IF NEGATE THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE @ * + >R
			1+
		ELSE
			DROP R> 0 LEAVE
		THEN
	AGAIN
;

: MOD 2DUP / * - ;

: /MOD \ ( num1 num2 -- num3 mod )
	2DUP / >R R@ * - R> SWAP
;

: (.)  \ ( num -- )
	DUP 0 = 
	IF
		DROP 48 EMIT LEAVE
	THEN
	
	DUP 0 < IF NEGATE 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP
		IF
			BASE @ /MOD 
			48 OVER 9 > IF 7 + THEN
			+ SWAP
		ELSE
			\ spit out the string
			DROP
			R> IF 45 EMIT THEN
			BEGIN DUP IF EMIT ELSE DROP LEAVE THEN AGAIN
		THEN
	AGAIN
;

: . BL (.) ;

HEX
: HEX.     BASE @ SWAP HEX DUP 10 < IF 0 (.) THEN (.) BASE ! ; DECIMAL
: DECIMAL. BASE @ SWAP DECIMAL (.) BASE ! ;
: BINARY.  BASE @ SWAP BINARY  (.) BASE ! ;

: MIN 2DUP > IF SWAP THEN DROP ; 
: MAX 2DUP < IF SWAP THEN DROP ; 

: .S 
	BL DEPTH 0 < 
	IF S" Stack underflow!" COUNT TYPE RESET THEN
	DEPTH 0 =
	IF 40 EMIT 237 EMIT 41 EMIT LEAVE THEN
	40 EMIT
	DEPTH 1- >R
	BEGIN 
		R@ PICK . R@ 
		IF
			R> 1- >R
		ELSE
			RDROP BL 41 EMIT LEAVE
		THEN
	AGAIN
;

: .(MEM_SZ) S" Memory: " CT MEM_SZ DUP HEX. S"  (" CT . BL S" )" CT ;
: .(HERE) S" HERE: " CT HERE DUP HEX. S"  (" CT . BL S" )" CT ;
: .(LAST) LAST DUP S" LAST: " CT HEX. S"  (" CT . BL S" )" CT ;

: .WORD-SHORT DUP DICT>NAME CT BL @ ;
: .WORD-LONG  
		DUP HEX. S" :" CT BL
		DUP DICT>NAME CT BL
		DUP DICT.GetXT 40 EMIT HEX. 41 EMIT \ DEBUG
		DUP DICT>FLAGS C@ \ DEBUG
		DUP S" , Flags: " CT HEX. \ DEBUG
		DUP FLAGS.ISINLINE? IF S"  (INLINE)" CT THEN \ DEBUG
		FLAGS.ISIMMEDIATE? IF S"  (IMMEDIATE)" CT THEN \ DEBUG
		CRLF @
;

: WORDS               LAST BEGIN DUP 0 = IF DROP CRLF LEAVE THEN .WORD-SHORT AGAIN ;
: WORDSV .(LAST) CRLF LAST BEGIN DUP 0 = IF DROP CRLF LEAVE THEN .WORD-LONG  AGAIN ;

: WORDS-OLD \ ( -- )
	LAST DUP HEX. 58 EMIT BL
	BEGIN
		DUP 0 =
		IF
			DROP CRLF LEAVE
		THEN
		@
	AGAIN
;

\ Prints the last <x> words
: .lastx CR LAST SWAP 0
    BEGIN
        2DUP > IF
            ROT .WORD-LONG -ROT 1+ 
        ELSE
            DROP DROP DROP LEAVE
        THEN
    AGAIN ;

: EXECUTE RDROP >R ; \ ( addr -- )

\ ( addr1 -- addr2 )
: find.ret
	BEGIN
		DUP C@ 
		<asm> CPUSH RET </asm> =
		IF
			LEAVE
		THEN
		1+
	AGAIN
;

: (inline) \ ( from to -- )
	2DUP < IF SWAP THEN
	BEGIN
		DUP C@ C,
		1+ 2DUP >
	WHILE
	2DROP
;

: DOES>
	R> DUP find.ret
	DUP >R
	1+
	(inline)
;

: Copy.INLINE \ ( XT -- )
	\ Skip over the DICTP
	DUP C@ <asm> CPUSH DICTP </asm> =
	IF 
		1+ CELL +
	THEN

	DUP find.ret
	(inline)
;

: strlen 0 SWAP 
	BEGIN
		TUCK C@ DUP
		IF
			DROP 1+ SWAP 1+ 1
		THEN
	WHILE
	NIP
;

: cstr, \ ( start -- )
	DUP C@ 
	OVER + 1+ 1+
	(inline)
;

: [COMPILE] \ ( XT flags -- )
	DUP FLAGS.ISIMMEDIATE? \ Immediate?
	IF
		DROP EXECUTE
	ELSE
		FLAGS.ISINLINE? 
		IF
			Copy.INLINE
		ELSE
			<asm> CPUSH CALL </asm> C, ,
		THEN
	THEN
;

: isPostpone <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA

: POSTPONE.rt
	R@ @ DICT.GetXT
	R@ @ DICT.GetFLAGS
	R> CELL + >R
	[COMPILE]
;

LAST DICT.GetXT
: POSTPONE  \ compile call to POSTPONE.rt
	<asm> CPUSH CALL </asm> C,
	<asm> PUSH , </asm> ,
	isPostpone ON
; IMMEDIATE

: executeWord  \ ( addr -- )
	>R R@ findInDict \ ( addr -- XT FLAGS found )
	IF
		RDROP
		?COMPILING
		IF
			isPostpone @ 
			IF
				DROP XT.GetDICTP ,
				isPostpone OFF
			ELSE
				DUP FLAGS.ISIMMEDIATE? \ Immediate?
				IF
					DROP EXECUTE
				ELSE
					[COMPILE]
				THEN
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE \ word not found
		2DROP \ discard IMM and XT place holders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				isPostpone @ 
				IF
					RESET	\ POSTPONE for literals not implemented yet
					isPostpone OFF
				ELSE
					DUP 0 255 BETWEEN
					IF
						<asm> CPUSH CPUSH </asm> C, C,
					ELSE
						<asm> CPUSH PUSH </asm> C, ,
					THEN
				THEN
			THEN
		ELSE
			\ . LAST . \ debug
			DROP
			R@ ZTYPE S" ??" CT RESET     \ TODO: error
		THEN
		RDROP
	THEN
;

: executeInput 
	BEGIN 
		>IN @ skipWS >IN ! 
		>IN @ C@  \ <EOL>?
		IF
			>IN @ getOneWord 
			>IN ! executeWord
		ELSE
			LEAVE
		THEN
	AGAIN
;

: Pad LAST 200 - 
	DUP HERE < IF
		S" Out of Memory!" RESET
	THEN
; 
\ : (Pad) <asm> .HERE 2 + .CELL + .LITERAL </asm> ; 0 .COMMA
\ : Pad (Pad) @ ; 

: LoadingFromFile? INPUT-FP @ ; \ ( -- bool ) 

: getLineFromFile \ ( addr sz fp -- )
	\ DROP 0 LEAVE
	200 INPUT-FP @ FREADLINE 0 =
	IF 
		INPUT-FP OFF
	THEN
;

: getLine \ ( -- addr )
	\ tmp-init 200 tmp-alloc (Pad) !
	0 Pad DUP 1+ >IN ! C!

	LoadingFromFile? IF
		Pad getLineFromFile
		LEAVE
	THEN

	BEGIN
		0 >IN @ C!     \ Null term
		GETCH 

		DUP 13 = IF 
			DROP Pad BL LEAVE 
		THEN

		DUP 9 = IF     \ Tab?
			DROP 32    \ Change it into a BL
		THEN
		
		DUP 8 = IF       \ Backspace?
			Pad C@ 0 > IF 
				Pad C--
				>IN --
				DUP EMIT BL EMIT
			ELSE
				DROP
			THEN
		ELSE
			DUP 32 127 BETWEEN IF
				DUP EMIT
				>IN @ C! 
				>IN ++
				Pad C++
			ELSE
				DROP
			THEN
		THEN
	AGAIN
;

: strcpy2c \ ( from to -- ) from is NOT counted, to is to get count byte
	\ 65 EMIT OVER . DUP . \ DEBUG
	DUP >R					\ from to
	0 OVER C!				\ from to (init count)
	1+ SWAP					\ to+1 from
	BEGIN
		DUP C@ DUP			\ to from ch ch
		IF					\ to from ch
			2 PICK C!		\ to from
			SWAP 1+ SWAP 1+
			R@ C++
		ELSE				\ to from ch
			ROT C! DROP
			RDROP
			LEAVE
		THEN
	AGAIN
;

: Define-Word \ ( addr -- )
	LAST OVER strlen 2 CELLS 3 + + - 
	DUP >R >R					\ Save new LAST
	LAST R@  !  R> CELL + >R	\ NEXT
	HERE R@  !  R> CELL + >R	\ XT
	0    R@ C!  R> 1+ >R		\ IMM
	R> strcpy2c					\ LEN + NAME
	R> (LAST) !
;

: IMMEDIATE LAST DICT>FLAGS DUP C@ FLAG_IMMEDIATE OR SWAP C! ;
: INLINE    LAST DICT>FLAGS DUP C@ FLAG_INLINE    OR SWAP C! ;

: CREATE-NAME \ ( -- )
	>IN @ skipWS >IN ! 
	>IN @ C@ 
	IF
		>IN @ getOneWord >IN ! 
		DUP C@
		IF
			Define-Word
			<asm> CPUSH DICTP </asm> C,
			LAST ,
		ELSE
			DROP RESET
		THEN
	THEN
;

: : CREATE-NAME STATE ON ;
: :NONAME HERE STATE ON ;

: ; \ ( -- )
	?COMPILING 
	IF
		<asm> CPUSH RET </asm> C,
		STATE OFF
	ELSE
		RESET
	THEN
; IMMEDIATE

: LAST? LAST DICT>NAME COUNT TYPE ;

: (FL) \ Forgets the last word
	LAST CELL + @ DP ! 
	LAST @ (LAST) ! 
;

: .fl (FL) LAST? ;

: resetState ?COMPILING 
	IF (FL) THEN 
	STATE OFF
	isPostpone OFF
	DECIMAL
;

: ALLOT HERE + DP ! ;

: (const) <asm> CPUSH PUSH </asm> C, , <asm> CPUSH RET </asm> C, ;
: CONSTANT CREATE-NAME (const) ; INLINE
: VARIABLE CREATE-NAME HERE 2 + CELL + (const) 0 , ; INLINE
: CVARIABLE CREATE-NAME HERE 2 + 1 + (const) 0 C, ; INLINE

: ? @ . ; \ ( addr -- )
: C? C@ . ; \ ( addr -- )

: FREE LAST HERE - ;
: FREE? FREE . S"  bytes free." CT ;

: ascii. DUP HEX. BL DUP DECIMAL. BL EMIT ;
: ascii 2DUP < IF SWAP THEN BEGIN CRLF DUP ascii. 1+ 2DUP > WHILE 2DROP ;

: mainLoop 
	resetState 
	BEGIN 
		tmp-init
		?COMPILING 0= IF S"  OK" CT .S THEN
		CRLF getLine 1+ >IN ! 
		executeInput BL 
	AGAIN ;

99 STATE !
: main STATE @ 99 = IF STATE OFF S" Hello." CT THEN mainLoop ;

: fn S" img-4th.bin" ;
: img-save 
   fn 1 1 FOPEN IF
       >R
       0 MEM_SZ R@ FWRITE 
	   . S"  bytes written." CT
       R> FCLOSE
   ELSE
       S" cannot open " CT fn CT RESET
   THEN ;

: dump ( start end -- ) CR 2DUP < IF SWAP THEN BEGIN 2DUP < IF 2DROP LEAVE THEN DUP BL C@ HEX. 1+ AGAIN ;
: dump.num ( start num -- ) OVER + dump ;

\ ------------------------------------------------------------------------------------
\ A stack is comprised of 3 parts, [stack-pointer] [stack-last] [stack-data]
\ The stack "bottom" is the first CELL after the stack-pointer
\
: (stk-ptr) ;                                   \ ( stk -- stk-ptr-addr )
: (stk-top) CELL + ;		        	        \ ( stk -- last-cell-addr )

: stk-bottom CELL DUP + + ;                     \ ( stk -- bottom )
: stk-top (stk-top) @ ;			                \ ( stk -- last-cell-addr )
: stk-ptr (stk-ptr) @ ;                         \ ( stk -- stk-ptr )
: stk-reset DUP stk-bottom SWAP (stk-ptr) ! ;   \ ( stk -- )
: stk-depth DUP stk-ptr                         \ ( stk -- depth )
    SWAP stk-bottom - CELL / ;

: stk-init 								        \ ( sz stk -- )
    SWAP CELLS ALLOT
    HERE OVER (stk-top) !
    CELL ALLOT stk-reset ;

: stk-over?                                     \ ( stk -- )
    DUP stk-top OVER stk-ptr <
    IF
        S" Stack overflow." CT
	    DROP RESET
    THEN 
    DROP ;

: stk-under?                                    \ ( stk -- )
    DUP stk-ptr OVER stk-bottom <=
    IF
		S" Stack empty." CT
	     stk-reset RESET
    THEN 
    DROP ;

: >stk DUP stk-over? (stk-ptr) TUCK @ !	        \ ( val stk -- )
    CELL += ;

: stk@ DUP stk-under? stk-ptr CELL - @ ;        \ ( stk -- val )

: stk> DUP stk@ SWAP                            \ ( stk -- val )
    (stk-ptr) CELL -= ;

\ ------------------------------------------------------------------------------------
: test-getLine \ ( fp -- addr num-read )
	Pad SWAP 200 SWAP
	FREADLINE \ ( addr sz fp -- num-read )
	Pad SWAP
	\ Pad DUP . C@ . 65 EMIT
;

: load 0 0 FOPEN 		\ ( filename -- ) 
	0= IF
		S" Cannot open file. CT LEAVE
	THEN
	INPUT-FP !
	BEGIN
		INPUT-FP @ test-getLine
		IF
			1+ >IN !
			\ >IN @ C@ .
			executeInput
		ELSE
			DROP
			INPUT-FP @ FCLOSE
			INPUT-FP OFF
			LEAVE
		THEN
	AGAIN ;

\ ******************************************************************************************
: STR.EMPTY ( addr -- addr ) 0 OVER ! ; INLINE

: STR.LEN ( addr -- addr len ) DUP C@ ; INLINE

: STR.CATC   ( addr ch -- addr )
    OVER
    DUP C++        \ increment len
    STR.LEN + 
    0 OVER 1+ C!   \ null-terminate
    C! ;

: STR.NULLTERM ( addr -- addr ) DUP STR.LEN + 1+ 0 SWAP C! ;

\ ******************************************************************************************
\ String literals
: I" 				 ( -- addr )
    HERE 100 + STR.EMPTY
	BEGIN 						
		>IN @ C@		        \ ( 1001 ch )
		DUP 0= IF
			S" missing closing " CT 34 EMIT
			RESET
		THEN
		>IN ++ 					\ ( 1001 ch )
		DUP 34 = IF				\ 34 = '"'
			DROP LEAVE 
		THEN
		STR.CATC
	AGAIN ;

: " ?COMPILING 0= IF I" LEAVE THEN
	<asm> CPUSH SLITERAL </asm> C, HERE 
	0 C,						\ count-byte
	BEGIN 						
		>IN @ C@
		DUP 0= IF
			DROP 1- DP !		\ reset HERE
			S" missing closing '" CT 34 EMIT 39 EMIT
			RESET
		THEN
		>IN ++
		DUP 34 = IF				\ 34 = '"'
			DROP HERE 0 C,		\ NT string ( 1001 1004 ) 
			OVER - SWAP C!	\ 
			LEAVE 
		THEN
		C,
	AGAIN ; IMMEDIATE

: ll S" loads.4th" load ;

CR
.(MEM_SZ) 44 EMIT BL
.(HERE)   44 EMIT BL 
.(LAST)   44 EMIT BL 
FREE? CR
