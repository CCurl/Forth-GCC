\ -----------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by forth-compiler.exe and an image of the VM's initial state is created.
\ It then writes that image to a file specified by -i:<filename>. The default is forth.bin.
\ It also disassembles that image, creating a listing file named by the -o arg, forth.asm.
\ The image file is read by the VM when it boots.
\
\ The compiler does these things ...
\ - it generates the following word: C,
\ - it generates the opcodes as words, e.g. "a.JMPNZ"
\ - it generates the forth primitives as INLINE words, e.g. @, C@ !, C!, SWAP, DUP, ...
\ - it generates the forth constants as INLINE words, e.g. BASE, DP, ...
\
\ NB: don't inline anything with a 12 in it ... that is RET
\ -----------------------------------------------------------------------------------------------

: INLINE    (LAST) @ 2 CELL * + DUP C@ 2 OR SWAP C! ;
: CELLS CELL * ; INLINE

: FLAG_IMMEDIATE 1 ; INLINE
: FLAG_INLINE    2 ; INLINE

: IMMEDIATE (LAST) @  2 CELLS + DUP C@ FLAG_IMMEDIATE OR SWAP C! ;

: LAST (LAST) @ ; INLINE
: HERE DP     @ ; INLINE

: , HERE ! HERE CELL + DP ! ;

: LOGLEVEL a.LOGLEVEL ; INLINE

: TRACE-ON  2 LOGLEVEL ;
: TRACE-OFF 0 LOGLEVEL ;
: DEBUG-ON  1 LOGLEVEL ;
: DEBUG-OFF 0 LOGLEVEL ;

: HEX     16 BASE C! ;
: DECIMAL 10 BASE C! ;
: OCTAL    8 BASE C! ;
: BINARY   2 BASE C! ;

: ON 1 SWAP ! ;
: OFF 0 SWAP ! ;

: [ 0 STATE ! ; IMMEDIATE
: ] 1 STATE ! ; IMMEDIATE

: ?COMPILING STATE @ ;
: THEN ?COMPILING .IF HERE SWAP ! .THEN ; IMMEDIATE
: IF   ?COMPILING .IF a.CPUSH a.JMPZ C, HERE 0 , .THEN ; IMMEDIATE
: ELSE ?COMPILING .IF a.CPUSH a.JMP  C, HERE SWAP 0 , HERE SWAP ! .THEN ; IMMEDIATE

: >IN      [ a.PUSH HERE 1 + CELL + , ] ; 0 , a.RET
: isNeg    [ a.PUSH HERE 1 + CELL + , ] ; 0 , a.RET

HEX : MEM_SZ 24 @ ; DECIMAL

: R@ R> DUP >R ; INLINE
: RDROP R> DROP   ; INLINE

: 2DUP  OVER OVER ; INLINE
: 2DROP DROP DROP ; INLINE
: TUCK  SWAP OVER ; INLINE
: NIP   SWAP DROP ; INLINE
: ROT   >R SWAP R> SWAP ; INLINE
: -ROT  SWAP >R SWAP R> ; INLINE

: 1+ 1 + ; INLINE
: 1- 1 - ; INLINE

: 2* 2 * ; INLINE 
: 2/ 2 / ; INLINE

: += OVER @ + SWAP ! ;   \ ( addr n -- )
: -= OVER @   SWAP - SWAP ! ;   \ ( addr n -- )

: ++ 1 += ;   \ ( addr -- )
: -- 1 -= ;   \ ( addr -- )

: C++ DUP C@ 1+ SWAP C! ;   \ ( addr -- )
: C-- DUP C@ 1- SWAP C! ;   \ ( addr -- )

: +!  TUCK @  + SWAP !  ;
: C+! TUCK C@ + SWAP C! ;

: 0= 0 =  ; INLINE
: <> = 0= ; INLINE
: <= > 0= ; INLINE
: >= < 0= ; INLINE

: TRUE 1 ; INLINE
: FALSE 0 ; INLINE
: NOT 0 = ; INLINE


: LEAVE ?COMPILING IF a.CPUSH a.RET C, THEN ; IMMEDIATE

: BEGIN ?COMPILING IF HERE THEN ; IMMEDIATE
: AGAIN ?COMPILING IF a.CPUSH a.JMP   C, , THEN ; IMMEDIATE
: WHILE ?COMPILING IF a.CPUSH a.JMPNZ C, , THEN ; IMMEDIATE
: UNTIL ?COMPILING IF a.CPUSH a.JMPZ  C, , THEN ; IMMEDIATE

: COUNT DUP 1 + SWAP C@ ;		\ ( addr1 --  addr2 num )

: TYPE     \ ( addr count -- ) 
	OVER + SWAP
	BEGIN
		2DUP <= IF 2DROP LEAVE THEN
		DUP C@ EMIT 1 +
	AGAIN ;

: CT COUNT TYPE ;

: \ 0 >IN @ C! ; IMMEDIATE

: ( BEGIN 
	>IN @ C@ 
	DUP 0= IF 
		S" missing closing ')'" CT RESET
	THEN
	>IN ++		
	41 = IF		\ 41 = ')'
		LEAVE 
	THEN
	AGAIN ; IMMEDIATE

: BL 32 EMIT ; INLINE
: CRLF 13 EMIT 10 EMIT ; INLINE
: CR CRLF ; INLINE

: BETWEEN											\ ( num min max -- bool )
	2 PICK 
	< IF 2DROP FALSE LEAVE THEN
	< 0=
;

: (tmp) [ a.PUSH HERE 1 + CELL + , ] ; 0 , a.RET
: tmp-init LAST (tmp) ! ;							\ ( -- )
: tmp-cur (tmp) @ ;
: tmp-alloc (tmp) TUCK @ SWAP - SWAP ! tmp-cur ;	\ ( size -- addr )

: PAD tmp-init 200 tmp-alloc ;
: getInput PAD 128 0 FREADLINE DROP PAD ;			\ ( -- addr )

: skipWS               								\ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		IF
			32 > 
			IF LEAVE ELSE 1+ THEN
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

: getOneWord										\ ( addr1 -- word-addr addr2 )
	\ NB: this word assumes that 
	\ leading WS has already been skipped.
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			\ If not at the end of the line, stick a 
			\ ZERO here and go to the next char.
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: DICT>NEXT ;
: DICT>XT     CELL + ;
: DICT>FLAGS  2 CELLS + ;
: DICT>NAME   DICT>FLAGS 1+ ;

: NEXT>DICT ;
: XT>DICT     CELL - ;
: FLAGS>DICT  2 CELLS - ;
: NAME>DICT   1- 2 CELLS - ;

: DICT.GetXT DICT>XT @ ; 1 DROP
: DICT.GetFLAGS DICT>FLAGS C@ ;

: DICTP>NAME 1+ @ DICT>NAME ;

: XT.GetDICTP 						\ ( XT -- dictp )
	DUP C@ a.CPUSH a.DICTP = 
	IF
		1+ @
	ELSE
		DROP RESET
	THEN
;


: FLAGS.ISIMMEDIATE? FLAG_IMMEDIATE AND ;
: FLAGS.ISINLINE?    FLAG_INLINE    AND ;

: DICT.GetIMMEDIATE DICT.GetFLAGS FLAGS.ISIMMEDIATE? ;
: DICT.GetINLINE    DICT.GetFLAGS FLAGS.ISINLINE? ;

: findInDict						\ ( addr -- XT IMM bool )
	LAST >R
	BEGIN
		R@ DUP
		IF
			\ addr is a null-termnated string with no count byte
			DICT>NAME 1+ OVER COMPAREI
			IF
				DROP R@ DICT.GetXT R> DICT.GetFLAGS 1
				LEAVE
			THEN
		ELSE
			2DROP R> 0 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

: isHEX? BASE C@ 16 = ;

: isNumChar?						\ ( ch -- val bool )
	DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	isHEX? 
	IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	0
;

: NEGATE 0 SWAP - ;
: ABS DUP 0 < IF NEGATE THEN ;

: isNumber?							\ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP isNeg C! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0 = \ end of word?
		IF 
			2DROP R> 
			isNeg C@ IF NEGATE THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE C@ * + >R
			1+
		ELSE
			DROP R> 0 LEAVE
		THEN
	AGAIN
;

: MOD 2DUP / * - ;

: /MOD 2DUP / DUP >R * - R> SWAP ;     \ ( num1 num2 -- num3 mod )

: (.)			\ ( num -- )
	DUP 0 = 
	IF
		DROP 48 EMIT LEAVE
	THEN
	
	DUP 0 < IF NEGATE 1 ELSE 0 THEN >R

	0 SWAP
	BEGIN
		DUP
		IF
			BASE C@ /MOD
			48 OVER 9 > IF 7 + THEN
			+ SWAP
		ELSE
			\ spit out the string
			DROP
			R> IF 45 EMIT THEN
			BEGIN DUP IF EMIT ELSE DROP LEAVE THEN AGAIN
		THEN
	AGAIN
;

: . BL (.) ;

HEX 
: HEX.     BASE C@ SWAP HEX DUP 10 < IF 30 EMIT THEN (.) BASE C! ; 
: DECIMAL. BASE C@ SWAP DECIMAL (.) BASE C! ;
: BINARY.  BASE C@ SWAP BINARY  (.) BASE C! ;
DECIMAL

: MIN 2DUP > IF SWAP THEN DROP ; 
: MAX 2DUP < IF SWAP THEN DROP ; 

: .S 
	BL DEPTH 0 < 
	IF S" Stack underflow!" COUNT TYPE RESET THEN
	DEPTH 0 =
	IF 40 EMIT 237 EMIT 41 EMIT LEAVE THEN
	40 EMIT
	DEPTH 1- >R
	BEGIN 
		R@ PICK . R@ 
		IF
			R> 1- >R
		ELSE
			RDROP BL 41 EMIT LEAVE
		THEN
	AGAIN
;

: .(MEM_SZ) S" Memory: " CT MEM_SZ DUP HEX. S"  (" CT (.) S" )" CT ;
: .(HERE)   S" HERE: "   CT HERE   DUP HEX. S"  (" CT (.) S" )" CT ;
: .(LAST)   S" LAST: "   CT LAST   DUP HEX. S"  (" CT (.) S" )" CT ;

: .WORD-SHORT DUP DICT>NAME CT BL @ ;
: WORDS LAST BEGIN DUP @ 0= IF DROP CRLF LEAVE THEN .WORD-SHORT AGAIN ;

: .WORD-LONG  
		DUP HEX. 58 EMIT BL
		DUP DICT>NAME CT BL
		DUP DICT.GetXT 40 EMIT HEX. 41 EMIT \ DEBUG
		DUP DICT>FLAGS C@ \ DEBUG
		DUP S" , Flags: " CT HEX. \ DEBUG
		DUP FLAGS.ISINLINE? IF S"  (INLINE)" CT THEN \ DEBUG
		FLAGS.ISIMMEDIATE? IF S"  (IMMEDIATE)" CT THEN \ DEBUG
		CRLF @ ;

: WORDSV .(LAST) CRLF LAST BEGIN DUP @ 0= IF DROP CRLF LEAVE THEN .WORD-LONG  AGAIN ;

: NUM-WORDS 0 >R LAST BEGIN DUP @ 0= IF DROP R> CRLF LEAVE THEN R> 1+ >R @ AGAIN ;

\ Prints the last <x> words
: .lastx CR LAST SWAP 0
    BEGIN
        2DUP > IF
            ROT .WORD-LONG -ROT 1+ 
        ELSE
            DROP DROP DROP LEAVE
        THEN
    AGAIN ;

: EXECUTE RDROP >R ;		\ ( addr -- )

: find.ret			\ ( addr1 -- addr2 )
	BEGIN
		DUP C@ 
		a.CPUSH a.RET =
		IF
			LEAVE
		THEN
		1+
	AGAIN
;

: (inline)		\ ( from to -- )
	2DUP < IF SWAP THEN
	BEGIN
		DUP C@ C,
		1+ 2DUP >
	WHILE
	2DROP
;

: DOES>
	R> DUP find.ret
	DUP >R
	1+
	(inline)
;

: Copy.INLINE		\ ( XT -- )
	\ Skip over the DICTP
	DUP C@ a.CPUSH a.DICTP =
	IF 
		1+ CELL +
	THEN

	DUP find.ret
	(inline)
;

: strlen 0 SWAP 
	BEGIN
		TUCK C@ DUP
		IF
			DROP 1+ SWAP 1+ 1
		THEN
	WHILE
	NIP
;

: cstr,			\ ( start -- )
	DUP C@ 
	OVER + 1+ 1+
	(inline)
;

: [COMPILE]		\ ( XT flags -- )
	FLAGS.ISINLINE? 
	IF
		Copy.INLINE
	ELSE
		a.CPUSH a.CALL C, ,
	THEN
;

: executeWord		\ ( addr -- )
	>R R@ findInDict \ ( addr -- XT FLAGS found )
	IF
		RDROP
		?COMPILING
		IF
			DUP FLAGS.ISIMMEDIATE? \ Immediate?
			IF
				DROP EXECUTE
			ELSE
				[COMPILE]
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE             \ word not found
		2DROP        \ discard IMM and XT place holders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				DUP 0 255 BETWEEN
				IF
					a.CPUSH a.CPUSH C, C,
				ELSE
					a.CPUSH a.PUSH C, ,
				THEN
			THEN
		ELSE
			DROP
			S" ??" CT RESET     \ TODO: error
		THEN
		RDROP
	THEN
;

: executeInput 
	BEGIN 
		>IN @ skipWS >IN ! 
		>IN @ C@  \ <EOL>?
		IF
			>IN @ getOneWord 
			>IN ! executeWord
		ELSE
			LEAVE
		THEN
	AGAIN
;

: Pad LAST 200 - 
	DUP HERE < IF
		S" Out of Memory!" RESET
	THEN
; 

: LoadingFromFile? INPUT-FP @ ;		\ ( -- bool ) 

: getLineFromFile		\ ( addr sz fp -- )
	\ DROP 0 LEAVE
	200 INPUT-FP @ FREADLINE 0 =
	IF 
		INPUT-FP OFF
	THEN
;

: getLine			\ ( -- addr )
	\ tmp-init 200 tmp-alloc (Pad) !
	0 Pad DUP 1+ >IN ! C!

	LoadingFromFile? IF
		Pad getLineFromFile
		LEAVE
	THEN

	BEGIN
		0 >IN @ C!     \ Null term
		GETCH 

		DUP 13 = IF 
			DROP Pad BL LEAVE 
		THEN

		DUP 9 = IF     \ Tab?
			DROP 32    \ Change it into a BL
		THEN

		DUP 3 = IF
			BYE
		THEN
		
		DUP 8 = IF       \ Backspace?
			Pad C@ 0 > IF 
				Pad C--
				>IN --
				DUP EMIT BL EMIT
			ELSE
				DROP
			THEN
		ELSE
			DUP 32 127 BETWEEN IF
				DUP EMIT
				>IN @ C! 
				>IN ++
				Pad C++
			ELSE
				DROP
			THEN
		THEN
	AGAIN
;

: strcpy2c			\ ( from to -- ) from is NOT counted, to is to get count byte
	\ 65 EMIT OVER . DUP . \ DEBUG
	DUP >R					\ from to
	0 OVER C!				\ from to (init count)
	1+ SWAP					\ to+1 from
	BEGIN
		DUP C@ DUP			\ to from ch ch
		IF					\ to from ch
			2 PICK C!		\ to from
			SWAP 1+ SWAP 1+
			R@ C++
		ELSE				\ to from ch
			ROT C! DROP
			RDROP
			LEAVE
		THEN
	AGAIN
;

: Define-Word		\ ( addr -- )
	LAST OVER strlen 2 CELLS 3 + + - 
	DUP >R >R					\ Save new LAST
	LAST R@  !  R> CELL + >R	\ NEXT
	HERE R@  !  R> CELL + >R	\ XT
	0    R@ C!  R> 1+ >R		\ IMM
	R> strcpy2c					\ LEN + NAME
	R> (LAST) !
;

: CREATE-NAME		\ ( -- )
	>IN @ skipWS >IN ! 
	>IN @ C@ 
	IF
		>IN @ getOneWord >IN ! 
		DUP C@
		IF
			Define-Word
			a.CPUSH a.DICTP C,
			LAST ,
		ELSE
			DROP RESET
		THEN
	THEN
;

: : CREATE-NAME STATE ON ;
: :NONAME HERE STATE ON ;

: ;
	a.CPUSH a.RET C,
	STATE OFF
; IMMEDIATE

: ForgetLast \ Forgets the last word
	LAST CELL + @ DP ! 
	LAST @ (LAST) ! 
;

: resetState ?COMPILING 
	IF ForgetLast THEN 
	STATE OFF
	DECIMAL
;

: ALLOT HERE + DP ! ;

: ? @ . ;		\ ( addr -- )
: C? C@ . ;		\ ( addr -- )

: FREE LAST HERE - ;
: FREE? FREE (.) S"  bytes free." CT ;

: mainLoop 
	resetState 
	BEGIN 
		tmp-init
		?COMPILING 0= IF S"  OK" CT .S THEN
		CRLF getLine 1+ >IN ! 
		executeInput BL 
	AGAIN ;

: main STATE @ 99 = IF STATE OFF S" Hello." CT THEN mainLoop ;

\ ------------------------------------------------------------------------------------
: file-getLine		\ ( fp -- addr num-read )
	Pad SWAP 200 SWAP
	FREADLINE \ ( addr sz fp -- num-read )
	Pad SWAP
	\ Pad CT CR \ DEBUG
;

: load 0 0 FOPEN 		\ ( filename -- ) 
	0= IF
		S" Cannot open file." CT LEAVE
	THEN
	INPUT-FP !
	BEGIN
		INPUT-FP @ file-getLine
		IF
			1+ >IN !
			\ >IN @ C@ .
			executeInput
		ELSE
			DROP
			INPUT-FP @ FCLOSE
			INPUT-FP OFF
			LEAVE
		THEN
	AGAIN ;

\ ******************************************************************************************
: STR.EMPTY 0 OVER ! ; INLINE		\ ( addr -- addr )

: STR.LEN DUP C@ ; INLINE		\ ( addr -- addr len )

: STR.CATC			\ ( addr ch -- addr )
    OVER
    DUP C++        \ increment len
    STR.LEN + 
    0 OVER 1+ C!   \ null-terminate
    C! ;

: STR.NULLTERM DUP STR.LEN + 1+ 0 SWAP C! ;			\ ( addr -- addr )

\ ******************************************************************************************
\ String literals
: I" 				 \ ( -- addr )
    HERE 100 + STR.EMPTY
	BEGIN 						
		>IN @ C@		        \ ( 1001 ch )
		DUP 0= IF
			S" missing closing " CT 34 EMIT
			RESET
		THEN
		>IN ++ 					\ ( 1001 ch )
		DUP 34 = IF				\ 34 = '"'
			DROP LEAVE 
		THEN
		STR.CATC
	AGAIN ;

: " ?COMPILING 0= IF 
		I" LEAVE 
	THEN
	
	a.CPUSH a.SLITERAL C,
	HERE 0 C,						\ count-byte placeholder
	BEGIN 						
		>IN @ C@
		DUP 0= IF
			DROP 1- DP !		\ reset HERE
			S" missing closing '" CT 34 EMIT 39 EMIT
			RESET
		THEN
		>IN ++
		DUP 34 = IF				\ 34 = '"'
			DROP HERE 0 C,		\ NT string ( 1001 1004 ) 
			OVER - 1- SWAP C!	\ 
			LEAVE 
		THEN
		C,
	AGAIN ; IMMEDIATE

: ll S" loads.4th" load ;

: sys-stats
	.(MEM_SZ) 44 EMIT BL
	.(HERE)   44 EMIT BL 
	.(LAST)   44 EMIT BL
	FREE? CR ;

sys-stats
99 STATE !
