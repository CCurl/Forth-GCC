\ -----------------------------------------------------------------------------------------------
\ This is the source code for the VM's boot loader.
\ This file is compiled by forth-compiler.exe and an image of the VM's initial state is created.
\ It then writes that image to a file specified by -i:<filename>. The default is forth.bin.
\ The image file is read by the VM (forth.exe) when it boots.
\
\ NB: don't inline anything with a 12 (0x0C) in it ... that is RET
\ -----------------------------------------------------------------------------------------------

\ Variables mess up the disassembler, put them first

VARIABLE (HERE)
VARIABLE (LAST)
VARIABLE BASE
VARIABLE STATE
VARIABLE (MEM_SZ)

VARIABLE >IN
VARIABLE (tmp)
VARIABLE #NEG
VARIABLE #LEN
VARIABLE INPUT-FP

.NOP. \ marks the end of the variables

: CELL 4 ;

: HERE (HERE) .FETCH. ;
: LAST (LAST) .FETCH. ;

: C, HERE .CSTORE. HERE 1    .ADD. (HERE) .STORE. ;
: ,  HERE .STORE.  HERE CELL .ADD. (HERE) .STORE. ;

: [ 0 STATE .STORE. ; .IMMEDIATE
: ] 1 STATE .STORE. ; .IMMEDIATE

: LITERAL	   1 C,   ;
: @			[  2 C, ] ; .INLINE
: !			[  3 C, ] ; .INLINE
: SWAP		[  4 C, ] ; .INLINE
: DROP		[  5 C, ] ; .INLINE
: DUP		[  6 C, ] ; .INLINE
: SLITERAL	   7 C,   ;
: JMP		   8 C,   ;
: JMPZ		   9 C,   ;
: JMPNZ		  10 C,   ;
: CALL		  11 C,   ;
: RET		  12 C,   ;
: OR		[ 13 C, ] ; .INLINE
: CLITERAL	  14 C,   ; .INLINE
: C@		[ 15 C, ] ; .INLINE
: C!		[ 16 C, ] ; .INLINE
: +			[ 17 C, ] ; .INLINE
: -			[ 18 C, ] ; .INLINE
: *			[ 19 C, ] ; .INLINE
: /			[ 20 C, ] ; .INLINE
: <			[ 21 C, ] ; .INLINE
: =			[ 22 C, ] ; .INLINE
: >			[ 23 C, ] ; .INLINE
: DICTP		  24 C,   ; .INLINE
: EMIT		[ 25 C, ] ; .INLINE
: OVER		[ 26 C, ] ; .INLINE
: COMPARE	[ 27 C, ] ; .INLINE
: FOPEN		[ 28 C, ] ; .INLINE
: FREAD		[ 29 C, ] ; .INLINE
: FREADLINE	[ 30 C, ] ; .INLINE
: FWRITE	[ 31 C, ] ; .INLINE
: FCLOSE	[ 32 C, ] ; .INLINE
: >R		[ 33 C, ] ; .INLINE
: R>		[ 34 C, ] ; .INLINE
: LOGLEVEL	[ 35 C, ] ; .INLINE
: AND		[ 36 C, ] ; .INLINE
: PICK		[ 37 C, ] ; .INLINE
: DEPTH		[ 38 C, ] ; .INLINE
: GETCH		[ 39 C, ] ; .INLINE
: COMPAREI	[ 40 C, ] ; .INLINE
\ : USINIT	[ 41 C, ] ; .INLINE
: USPUSH	[ 42 C, ] ; .INLINE
: USPOP		[ 43 C, ] ; .INLINE
: INC		[ 44 C, ] ; .INLINE
: RDEPTH	[ 45 C, ] ; .INLINE
: DEC		[ 46 C, ] ; .INLINE
: GETTICK	[ 47 C, ] ; .INLINE
: BREAK		[ 253 C, ] ; .INLINE
: RESET		[ 254 C, ] ; .INLINE
: BYE		[ 255 C, ] ; .INLINE

: INLINE    LAST 2 CELL * + DUP C@ 2 OR SWAP C! ;
: IMMEDIATE LAST 2 CELL * + DUP C@ 1 OR SWAP C! ;
: CELLS CELL * ; INLINE

: FLAG_IMMEDIATE 1 ; INLINE
: FLAG_INLINE    2 ; INLINE

: HEX     16 BASE ! ;
: DECIMAL 10 BASE ! ;
: OCTAL    8 BASE ! ;
: BINARY   2 BASE ! ;

: ON  1 SWAP ! ;
: OFF 0 SWAP ! ;

: ?COMPILING STATE @ ;
: IF   ?COMPILING .IF JMPZ HERE 0 ,                  .THEN ; IMMEDIATE
: ELSE ?COMPILING .IF JMP  HERE SWAP 0 , HERE SWAP ! .THEN ; IMMEDIATE
: THEN ?COMPILING .IF HERE SWAP !                    .THEN ; IMMEDIATE

: BEGIN ?COMPILING IF HERE    THEN ;    IMMEDIATE 
: AGAIN ?COMPILING IF JMP   , THEN ;    IMMEDIATE
: WHILE ?COMPILING IF JMPNZ , THEN ;    IMMEDIATE
: UNTIL ?COMPILING IF JMPZ  , THEN ;    IMMEDIATE
: LEAVE ?COMPILING IF RET     THEN ;    IMMEDIATE

: MEM_SZ (MEM_SZ) @ ;

: TRACE-ON  2 LOGLEVEL ; INLINE
: TRACE-OFF 0 LOGLEVEL ; INLINE
: DEBUG-ON  1 LOGLEVEL ; INLINE
: DEBUG-OFF 0 LOGLEVEL ; INLINE

: R@ R> DUP >R ; INLINE
: RDROP R> DROP   ; INLINE

: 2DUP  OVER OVER ; INLINE
: 2DROP DROP DROP ; INLINE
: TUCK  SWAP OVER ; INLINE
: NIP   SWAP DROP ; INLINE
: ROT   >R SWAP R> SWAP ; INLINE
: -ROT  SWAP >R SWAP R> ; INLINE

: 1+ INC ; INLINE
: 1- DEC ; INLINE

: 2* 2 * ; INLINE 
: 2/ 2 / ; INLINE

: += OVER @ + SWAP ! ;   \ ( addr n -- )
: -= OVER @   SWAP - SWAP ! ;   \ ( addr n -- )

: ++ 1 += ;   \ ( addr -- )
: -- 1 -= ;   \ ( addr -- )

: C++ DUP C@ 1+ SWAP C! ;   \ ( addr -- )
: C-- DUP C@ 1- SWAP C! ;   \ ( addr -- )

: +!  TUCK @  + SWAP !  ;
: C+! TUCK C@ + SWAP C! ;

: 0= 0 =  ; INLINE
: <> = 0= ; INLINE
: <= > 0= ; INLINE
: >= < 0= ; INLINE

: TRUE 1 ; INLINE
: FALSE 0 ; INLINE
: NOT 0 = ; INLINE

: COUNT DUP 1+ SWAP C@ ;		\ ( addr1 --  addr2 num )

: TYPE     \ ( addr count -- ) 
	OVER + SWAP
	BEGIN
		2DUP <= IF 2DROP LEAVE THEN
		DUP C@ EMIT 1+
	AGAIN ;

: CT COUNT TYPE ;

: \ 0 >IN @ C! ; IMMEDIATE

: ( BEGIN 
	>IN @ C@ 
	DUP 0= IF 
		S" missing closing ')'" CT RESET
	THEN
	>IN ++		
	41 = IF		\ 41 = ')'
		LEAVE 
	THEN
	AGAIN ; IMMEDIATE

: BL 32 EMIT ; INLINE
: CRLF 13 EMIT 10 EMIT ; INLINE
: CR CRLF ; INLINE

: BETWEEN											\ ( num min max -- bool )
	2 PICK 
	< IF 2DROP FALSE LEAVE THEN
	< 0=
;

: tmp-init LAST (tmp) ! ;							\ ( -- )
: tmp-cur (tmp) @ ;
: tmp-alloc (tmp) TUCK @ SWAP - SWAP ! tmp-cur ;	\ ( size -- addr )

: PAD tmp-init 200 tmp-alloc ;
: getInput PAD 128 0 FREADLINE DROP PAD ;			\ ( -- addr )

: skipWS               								\ ( addr1 -- addr2 )
	BEGIN
		DUP C@ DUP
		IF
			32 > 
			IF LEAVE ELSE 1+ THEN
		ELSE
			DROP LEAVE
		THEN
	AGAIN
;

: getOneWord										\ ( addr1 -- word-addr addr2 )
	\ NB: this word assumes that 
	\ leading WS has already been skipped.
	DUP >R >R
	BEGIN
		R@ C@ 32 > IF
			R> 1+ >R
		ELSE
			\ If not at the end of the line, stick a 
			\ ZERO here and go to the next char.
			R@ C@ 
			IF
				0 R@ C! R> 1+ >R
			THEN
			R> R> SWAP LEAVE
		THEN
	AGAIN
;

: DICT>NEXT ;
: DICT>XT     CELL + ;
: DICT>FLAGS  2 CELLS + ;
: DICT>NAME   DICT>FLAGS 1+ ;

: NEXT>DICT ;
: XT>DICT     CELL - ;
: FLAGS>DICT  2 CELLS - ;
: NAME>DICT   1- 2 CELLS - ;

: DICT.GetXT DICT>XT @ ; 1 DROP
: DICT.GetFLAGS DICT>FLAGS C@ ;

: DICTP>NAME 1+ @ DICT>NAME ;

: XT.GetDICTP 						\ ( XT -- dictp )
	DUP C@ [ CLITERAL DICTP ] = 
	IF
		1+ @
	ELSE
		DROP RESET
	THEN
;

: FLAGS.ISIMMEDIATE? FLAG_IMMEDIATE AND ;
: FLAGS.ISINLINE?    FLAG_INLINE    AND ;

: DICT.GetIMMEDIATE DICT.GetFLAGS FLAGS.ISIMMEDIATE? ;
: DICT.GetINLINE    DICT.GetFLAGS FLAGS.ISINLINE? ;

: findInDict						\ ( addr -- XT IMM bool )
	LAST >R
	BEGIN
		R@ DUP
		IF
			\ addr is a null-termnated string with no count byte
			DICT>NAME 1+ OVER COMPAREI
			IF
				DROP R@ DICT.GetXT R> DICT.GetFLAGS 1
				LEAVE
			THEN
		ELSE
			2DROP R> 0 0 LEAVE
		THEN
		R> @ >R
	AGAIN
;

: isHEX? BASE @ 16 = ;

: isNumChar?						\ ( ch -- val bool )
	DUP 48 57 BETWEEN IF 48 - 1 LEAVE THEN
	isHEX? 
	IF
		DUP 65  70 BETWEEN IF 55 - 1 LEAVE THEN
		DUP 97 102 BETWEEN IF 87 - 1 LEAVE THEN
	THEN
	0
;

: NEGATE 0 SWAP - ;
: ABS DUP 0 < IF NEGATE THEN ;

: isNumber?							\ ( addr -- num bool )
	\ find out if it is negative
	DUP C@ 45 = DUP #NEG ! IF 1+ THEN
	
	\ accumulate the result on the return stack
	0 >R
	BEGIN
		DUP C@
		DUP 0 = \ end of word?
		IF 
			2DROP R> 
			#NEG @ IF NEGATE THEN
			1 LEAVE
		THEN

		isNumChar? 
		IF
			R> BASE @ * + >R
			1+
		ELSE
			DROP R> 0 LEAVE
		THEN
	AGAIN
;

: MOD 2DUP / * - ;                \ ( n1 n2 -- r )
: /MOD 2DUP / DUP >R * - R> ;     \ ( n1 n2 -- r q )
: SPACE 32 EMIT ;

: <# #NEG OFF #LEN OFF DUP 0 < IF NEGATE #NEG ON THEN 0 SWAP ; \ ( u1 -- 0 u2 )
: # BASE @ /MOD SWAP 48 + DUP 57 > IF 7 + THEN #LEN ++ SWAP ; \  ( u1 -- c u2 )
: #S BEGIN # DUP 0= UNTIL ;                  \  ( u1 -- u2 )
: #> ;
: #P- DROP #NEG @ IF 45 EMIT THEN ;
: #P #P- BEGIN EMIT DUP 0= UNTIL DROP ;      \ ( 0 ... n 0 -- )

: (.) <# #S #> #P ;
: . (.) SPACE ;
: .2 <# # # #> #P ;
: .3 <# # # # #> #P ;
: .4 <# # # # # #> #P ;

HEX 
: HEX.     BASE @ SWAP HEX (.) BASE ! ; 
: HEX.2    BASE @ SWAP HEX .2 BASE ! ; 
: HEX.4    BASE @ SWAP HEX .4 BASE ! ; 
: DECIMAL. BASE @ SWAP DECIMAL (.) BASE ! ;
: BINARY.  BASE @ SWAP BINARY  (.) BASE ! ;
DECIMAL

: MIN 2DUP > IF SWAP THEN DROP ; 
: MAX 2DUP < IF SWAP THEN DROP ; 

: .S 
	BL DEPTH 0 < 
	IF S" Stack underflow!" COUNT TYPE RESET THEN
	DEPTH 0 =
	IF 40 EMIT 237 EMIT 41 EMIT LEAVE THEN
	40 EMIT SPACE
	DEPTH 1- >R
	BEGIN 
		R@ PICK . R@ 
		IF
			R> 1- >R
		ELSE
			RDROP 41 EMIT LEAVE
		THEN
	AGAIN
;

: .(MEM_SZ) S" Memory: " CT MEM_SZ DUP HEX. S"  (" CT (.) S" )" CT ;
: .(HERE)   S" HERE: "   CT HERE   DUP HEX. S"  (" CT (.) S" )" CT ;
: .(LAST)   S" LAST: "   CT LAST   DUP HEX. S"  (" CT (.) S" )" CT ;

: .WORD-SHORT DUP DICT>NAME CT BL @ ;
: WORDS LAST BEGIN DUP @ 0= IF DROP CRLF LEAVE THEN .WORD-SHORT AGAIN ;

: .WORD-LONG  
		DUP HEX. 58 EMIT BL
		DUP DICT>NAME CT BL
		DUP DICT.GetXT 40 EMIT HEX.4 41 EMIT \ DEBUG
		DUP DICT>FLAGS C@ \ DEBUG
		DUP S" , Flags: " CT HEX.2 \ DEBUG
		DUP FLAGS.ISINLINE? IF S"  (INLINE)" CT THEN \ DEBUG
		FLAGS.ISIMMEDIATE? IF S"  (IMMEDIATE)" CT THEN \ DEBUG
		CRLF @ ;

: WORDSV .(LAST) CRLF LAST BEGIN DUP @ 0= IF DROP CRLF LEAVE THEN .WORD-LONG  AGAIN ;

: NUM-WORDS 0 >R LAST BEGIN DUP @ 0= IF DROP R> CRLF LEAVE THEN R> 1+ >R @ AGAIN ;

\ Prints the last <x> words
: .lastx CR LAST SWAP
    BEGIN
            SWAP .WORD-LONG SWAP
			1- 
			DUP 
	WHILE
    DROP DROP ;

: EXECUTE RDROP >R ;		\ ( addr -- )

: find.ret			\ ( addr1 -- addr2 )
	BEGIN
		DUP C@ 
		[ CLITERAL RET ] =
		IF
			LEAVE
		THEN
		1+
	AGAIN
;

: (inline)		\ ( from to -- )
	2DUP < IF SWAP THEN
	BEGIN
		DUP C@ C,
		1+ 2DUP >
	WHILE
	2DROP
;

: DOES>
	R> DUP find.ret
	DUP >R
	1+
	(inline)
;

: Copy.INLINE		\ ( XT -- )
	\ Skip over the DICTP
	DUP C@ [ CLITERAL DICTP ] =
	IF 
		1+ CELL +
	THEN

	DUP find.ret
	(inline)
;

: strlen 0 SWAP 
	BEGIN
		TUCK C@ DUP
		IF
			DROP 1+ SWAP 1+ 1
		THEN
	WHILE
	NIP
;

: cstr,			\ ( start -- )
	DUP C@ 
	OVER + 1+ 1+
	(inline)
;

: [COMPILE]		\ ( XT flags -- )
	FLAGS.ISINLINE? 
	IF
		Copy.INLINE
	ELSE
		CALL ,
	THEN
;

: executeWord		\ ( addr -- )
	>R R@ findInDict \ ( addr -- XT FLAGS found )
	IF
		RDROP
		?COMPILING
		IF
			DUP FLAGS.ISIMMEDIATE? \ Immediate?
			IF
				DROP EXECUTE
			ELSE
				[COMPILE]
			THEN
		ELSE
			DROP EXECUTE
		THEN
	ELSE             \ word not found
		2DROP        \ discard IMM and XT place holders
		R@ isNumber? \ ( addr -- num bool )
		IF
			?COMPILING
			IF
				DUP 0 255 BETWEEN
				IF
					CLITERAL C,
				ELSE
					LITERAL   ,
				THEN
			THEN
		ELSE
			DROP
			S" ??" CT RESET     \ TODO: error
		THEN
		RDROP
	THEN
;

: executeInput 
	BEGIN 
		>IN @ skipWS >IN ! 
		>IN @ C@  \ <EOL>?
		IF
			>IN @ getOneWord 
			>IN ! executeWord
		ELSE
			LEAVE
		THEN
	AGAIN
;

: Pad LAST 200 - 
	DUP HERE < IF
		S" Out of Memory!" RESET
	THEN
; 

: LoadingFromFile? INPUT-FP @ ;		\ ( -- bool ) 

: getLineFromFile		\ ( addr sz fp -- )
	\ DROP 0 LEAVE
	200 INPUT-FP @ FREADLINE 0 =
	IF 
		INPUT-FP OFF
	THEN
;

: getLine			\ ( -- addr )
	\ tmp-init 200 tmp-alloc (Pad) !
	0 Pad DUP 1+ >IN ! C!

	LoadingFromFile? IF
		Pad getLineFromFile
		LEAVE
	THEN

	BEGIN
		0 >IN @ C!     \ Null term
		GETCH 

		DUP 13 = IF 
			DROP Pad BL LEAVE 
		THEN

		DUP 9 = IF     \ Tab?
			DROP 32    \ Change it into a BL
		THEN

		DUP 3 = IF
			BYE
		THEN
		
		DUP 8 = IF       \ Backspace?
			Pad C@ 0 > IF 
				Pad C--
				>IN --
				DUP EMIT BL EMIT
			ELSE
				DROP
			THEN
		ELSE
			DUP 32 127 BETWEEN IF
				DUP EMIT
				>IN @ C! 
				>IN ++
				Pad C++
			ELSE
				DROP
			THEN
		THEN
	AGAIN
;

: strcpy2c			\ ( from to -- ) from is NOT counted, to is to get count byte
	\ 65 EMIT OVER . DUP . \ DEBUG
	DUP >R					\ from to
	0 OVER C!				\ from to (init count)
	1+ SWAP					\ to+1 from
	BEGIN
		DUP C@ DUP			\ to from ch ch
		IF					\ to from ch
			2 PICK C!		\ to from
			SWAP 1+ SWAP 1+
			R@ C++
		ELSE				\ to from ch
			ROT C! DROP
			RDROP
			LEAVE
		THEN
	AGAIN
;

: Define-Word		\ ( addr -- )
	LAST OVER strlen 2 CELLS 3 + + - 
	DUP >R >R					\ Save new LAST
	LAST R@  !  R> CELL + >R	\ NEXT
	HERE R@  !  R> CELL + >R	\ XT
	0    R@ C!  R> 1+ >R		\ IMM
	R> strcpy2c					\ LEN + NAME
	R> (LAST) !
;

: CREATE-NAME		\ ( -- )
	>IN @ skipWS >IN ! 
	>IN @ C@ 
	IF
		>IN @ getOneWord >IN ! 
		DUP C@
		IF
			Define-Word
			DICTP
			LAST ,
		ELSE
			DROP RESET
		THEN
	THEN
;

: : CREATE-NAME STATE ON ;
: :NONAME HERE STATE ON ;

: ;
	RET
	STATE OFF
; IMMEDIATE

: ForgetLast \ Forgets the last word
	LAST CELL + @ (HERE) ! 
	LAST @ (LAST) ! 
;

: resetState ?COMPILING 
	IF ForgetLast THEN 
	STATE OFF
	DECIMAL
;

: ALLOT HERE + (HERE) ! ;

: ? @ . ;		\ ( addr -- )
: C? C@ . ;		\ ( addr -- )

: FREE LAST HERE - ;
: .FREE FREE (.) S"  bytes free." CT ;

: mainLoop 
	resetState 
	BEGIN 
		tmp-init
		?COMPILING 0= IF S"  OK" CT .S THEN
		CRLF getLine 1+ >IN ! 
		executeInput BL 
	AGAIN ;

: main STATE @ 99 = IF STATE OFF S" Hello." CT THEN mainLoop ;

\ ------------------------------------------------------------------------------------
: file-getLine		\ ( fp -- addr num-read )
	Pad SWAP 200 SWAP
	FREADLINE \ ( addr sz fp -- num-read )
	Pad SWAP
	\ Pad CT CR \ DEBUG
;

: load 0 0 FOPEN 		\ ( filename -- ) 
	0= IF
		S" Cannot open file." CT LEAVE
	THEN
	INPUT-FP !
	BEGIN
		INPUT-FP @ file-getLine
		IF
			1+ >IN !
			\ >IN @ C@ .
			executeInput
		ELSE
			DROP
			INPUT-FP @ FCLOSE
			INPUT-FP OFF
			LEAVE
		THEN
	AGAIN ;

\ ******************************************************************************************
: STR.EMPTY 0 OVER ! ; INLINE		\ ( addr -- addr )

: STR.LEN DUP C@ ; INLINE		\ ( addr -- addr len )

: STR.CATC			\ ( addr ch -- addr )
    OVER
    DUP C++        \ increment len
    STR.LEN + 
    0 OVER 1+ C!   \ null-terminate
    C! ;

: STR.NULLTERM DUP STR.LEN + 1+ 0 SWAP C! ;			\ ( addr -- addr )

\ ******************************************************************************************
\ String literals
: I" 				 \ ( -- addr )
    HERE 100 + STR.EMPTY
	BEGIN 						
		>IN @ C@		        \ ( 1001 ch )
		DUP 0= IF
			S" missing closing " CT 34 EMIT
			RESET
		THEN
		>IN ++ 					\ ( 1001 ch )
		DUP 34 = IF				\ 34 = '"'
			DROP LEAVE 
		THEN
		STR.CATC
	AGAIN ;

: " ?COMPILING 0= IF 
		I" LEAVE 
	THEN
	
	SLITERAL
	HERE 0 C,						\ count-byte placeholder
	BEGIN 						
		>IN @ C@
		DUP 0= IF
			DROP 1- (HERE) !		\ reset HERE
			S" missing closing '" CT 34 EMIT 39 EMIT
			RESET
		THEN
		>IN ++
		DUP 34 = IF				\ 34 = '"'
			DROP HERE 0 C,		\ NT string ( 1001 1004 ) 
			OVER - 1- SWAP C!	\ 
			LEAVE 
		THEN
		C,
	AGAIN ; IMMEDIATE

: ll S" loads.4th" load ;

: sys-info
	.(MEM_SZ) 44 EMIT BL
	.(HERE)   44 EMIT BL 
	.(LAST)   44 EMIT BL
	.FREE CR ;


: countTo 
    S" counting to " CT DUP . S" ... " CT
    1
    BEGIN
        2DUP < 
        IF
            2DROP LEAVE
        THEN
        1+ 
    AGAIN ;

: countTo-FAST
    S" counting to " CT DUP . S" ... " CT
    BEGIN
		1-
		DUP 
	WHILE 
    DROP ;

sys-info

\ This is so that forth-dis behaves as it used to
HEX
	CELL   08 !
	HERE   10 !
	LAST   14 !
	0A     18 ! \ BASE
	0      20 ! \ STATE
	MEM_SZ 24 !
DECIMAL
99 STATE !

\ CELL ADDR_CELL     = 0x08;
\ CELL ADDR_HERE     = 0x10;
\ CELL ADDR_LAST     = 0x14;
\ CELL ADDR_BASE     = 0x18;
\ CELL ADDR_STATE    = 0x20;
\ CELL ADDR_MEM_SZ   = 0x24;
